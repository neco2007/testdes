<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>6x6 Block Blast - Drag & Drop</title>
    <style>
        :root { --bg: #0f172a; --grid: #1e293b; --accent: #38bdf8; }
        body { font-family: sans-serif; background: var(--bg); color: white; display: flex; flex-direction: column; align-items: center; margin: 0; overflow: hidden; touch-action: none; }
        .score-board { font-size: 32px; font-weight: bold; margin: 20px 0; color: var(--accent); }
        canvas { background: var(--grid); border-radius: 8px; box-shadow: 0 10px 25px rgba(0,0,0,0.5); }
        #hand-area { display: flex; gap: 20px; margin-top: 30px; height: 120px; align-items: center; }
        .hand-slot { width: 100px; height: 100px; background: rgba(255,255,255,0.05); border-radius: 10px; display: flex; justify-content: center; align-items: center; }
    </style>
</head>
<body>

    <div class="score-board">SCORE: <span id="score">0</span></div>
    <canvas id="gameCanvas" width="360" height="360"></canvas>
    
    <div id="hand-area">
        <div class="hand-slot" id="slot-0"></div>
        <div class="hand-slot" id="slot-1"></div>
        <div class="hand-slot" id="slot-2"></div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');

    const ROWS = 6, COLS = 6, SIZE = 60;
    let grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
    let score = 0;
    let hand = [null, null, null];
    
    // ドラッグ中の状態管理
    let draggingPiece = null;
    let draggingIndex = -1;
    let dragX = 0, dragY = 0;
    let offsetX = 0, offsetY = 0;

    const SHAPES = [
        { color: "#00f0f0", matrix: [[1, 1, 1, 1]] },
        { color: "#f0f000", matrix: [[1, 1], [1, 1]] },
        { color: "#a000f0", matrix: [[0, 1, 0], [1, 1, 1]] },
        { color: "#f0a000", matrix: [[1, 0], [1, 0], [1, 1]] },
        { color: "#00f000", matrix: [[0, 1, 1], [1, 1, 0]] }
    ];

    function initGame() {
        fillHand();
        requestAnimationFrame(gameLoop);
    }

    function fillHand() {
        for (let i = 0; i < 3; i++) {
            if (!hand[i]) hand[i] = SHAPES[Math.floor(Math.random() * SHAPES.length)];
        }
    }

    function drawBlock(x, y, color, alpha = 1) {
        ctx.globalAlpha = alpha;
        ctx.fillStyle = color;
        ctx.fillRect(x + 2, y + 2, SIZE - 4, SIZE - 4);
        ctx.strokeStyle = "rgba(255,255,255,0.2)";
        ctx.strokeRect(x + 5, y + 5, SIZE - 10, SIZE - 10);
        ctx.globalAlpha = 1.0;
    }

    function gameLoop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 1. 盤面描画
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                ctx.strokeStyle = "#334155";
                ctx.strokeRect(c * SIZE, r * SIZE, SIZE, SIZE);
                if (grid[r][c]) drawBlock(c * SIZE, r * SIZE, grid[r][c]);
            }
        }

        // 2. ドラッグ中のプレビューと本体
        if (draggingPiece) {
            const rect = canvas.getBoundingClientRect();
            const gridX = Math.floor((dragX - rect.left) / SIZE);
            const gridY = Math.floor((dragY - rect.top) / SIZE);

            // 置ける場合のプレビュー
            if (canPlace(gridY, gridX, draggingPiece.matrix)) {
                draggingPiece.matrix.forEach((row, r) => {
                    row.forEach((cell, c) => {
                        if (cell) drawBlock((gridX + c) * SIZE, (gridY + r) * SIZE, draggingPiece.color, 0.3);
                    });
                });
            }

            // ドラッグ中のマウス位置にピースを表示
            draggingPiece.matrix.forEach((row, r) => {
                row.forEach((cell, c) => {
                    if (cell) drawBlock(dragX - rect.left - offsetX + (c * SIZE), dragY - rect.top - offsetY + (r * SIZE), draggingPiece.color);
                });
            });
        }
        
        // 手札の描画（簡易的にCanvas外の要素も意識しつつCanvasに描くなら...今回はCanvas内に手札を描くスタイルに簡略化も可ですが、HTML側で制御）
        renderHand();
        requestAnimationFrame(gameLoop);
    }

    function renderHand() {
        hand.forEach((piece, i) => {
            const slot = document.getElementById(`slot-${i}`);
            slot.innerHTML = '';
            if (piece && draggingIndex !== i) {
                const sCanvas = document.createElement('canvas');
                sCanvas.width = 80; sCanvas.height = 80;
                const sCtx = sCanvas.getContext('2d');
                const sSize = 20;
                piece.matrix.forEach((row, r) => {
                    row.forEach((cell, c) => {
                        if (cell) {
                            sCtx.fillStyle = piece.color;
                            sCtx.fillRect(c * sSize, r * sSize, sSize - 2, sSize - 2);
                        }
                    });
                });
                slot.appendChild(sCanvas);
            }
        });
    }

    function canPlace(row, col, matrix) {
        if (row < 0 || col < 0) return false;
        for (let r = 0; r < matrix.length; r++) {
            for (let c = 0; c < matrix[r].length; c++) {
                if (matrix[r][c]) {
                    if (row + r >= ROWS || col + c >= COLS || grid[row + r][col + c]) return false;
                }
            }
        }
        return true;
    }

    // イベントリスナー
    window.onmousedown = (e) => {
        for (let i = 0; i < 3; i++) {
            const slot = document.getElementById(`slot-${i}`);
            const rect = slot.getBoundingClientRect();
            if (e.clientX > rect.left && e.clientX < rect.right && e.clientY > rect.top && e.clientY < rect.bottom && hand[i]) {
                draggingPiece = hand[i];
                draggingIndex = i;
                offsetX = 30; offsetY = 30; // 掴み位置調整
                break;
            }
        }
    };

    window.onmousemove = (e) => {
        dragX = e.clientX;
        dragY = e.clientY;
    };

    window.onmouseup = (e) => {
        if (draggingPiece) {
            const rect = canvas.getBoundingClientRect();
            const gridX = Math.floor((e.clientX - rect.left) / SIZE);
            const gridY = Math.floor((e.clientY - rect.top) / SIZE);

            if (canPlace(gridY, gridX, draggingPiece.matrix)) {
                draggingPiece.matrix.forEach((row, r) => {
                    row.forEach((cell, c) => {
                        if (cell) grid[gridY + r][gridX + c] = draggingPiece.color;
                    });
                });
                hand[draggingIndex] = null;
                checkLines();
                if (hand.every(p => p === null)) fillHand();
            }
            draggingPiece = null;
            draggingIndex = -1;
        }
    };

    function checkLines() {
        let rowsToClear = [], colsToClear = [];
        for (let r = 0; r < ROWS; r++) if (grid[r].every(c => c !== 0)) rowsToClear.push(r);
        for (let c = 0; c < COLS; c++) {
            if (grid.every(r => r[c] !== 0)) colsToClear.push(c);
        }
        rowsToClear.forEach(r => grid[r].fill(0));
        colsToClear.forEach(c => grid.forEach(r => r[c] = 0));
        if (rowsToClear.length || colsToClear.length) {
            score += (rowsToClear.length + colsToClear.length) * 100;
            scoreElement.textContent = score;
        }
    }

    initGame();
</script>
</body>
</html>
